\documentclass[a4paper,10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[french,ruled,vlined,linesnumbered]{algorithm2e}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\usepackage{hyperref}
\hypersetup{colorlinks=true,urlcolor= blue,linkcolor= black}

\newcommand*{\itemb}{\item[$\bullet$]}
\newcommand*{\itemt}{\item[$\blacktriangleright$]}
\DeclareMathOperator{\degree}{degre}
\DeclareMathOperator{\taille}{taille}
\DeclareMathOperator{\voisin}{voisin}
\DeclareMathOperator{\voisins}{voisins}
\DeclareMathOperator{\degmax}{degmax}
\DeclareMathOperator{\argmax}{argmax}
\DeclareMathOperator{\argmin}{argmin}
\DeclareMathOperator{\cover}{cover}
\DeclareMathOperator{\nonempty}{nonempty}
\DeclareMathOperator{\true}{true}
\DeclareMathOperator{\false}{false}
\DeclareMathOperator{\leaf}{leaf}
\DeclareMathOperator{\parent}{parent}
\DeclareMathOperator{\Color}{color}
\DeclareMathOperator{\degrepositif}{degrePositif}

\title{Projet CAA : couverture par sommets}
\author{Thomas \bsc{Bellitto}\and Paul-Émile \bsc{Boutoille} \and Claire \bsc{Pennarun}}
\date{}

\begin{document}

\maketitle

\section*{Introduction}

Le projet consiste en l'implémentation d'algorithmes résolvant de manière approchée (en général) ou optimale (pour certaines classes de graphes) le problème Vertex-Cover.
Les algorithmes présentés ici renvoient une liste des sommets formant une couverture du graphe. Cette couverture n'est cependant pas forcément minimale.

Nous avons implémenté l'ensemble de ces algorithmes en langage C, car le groupe était plus à l'aise dans ce langage qu'en C++.

Nous avons développé une structure de graphes que nous détaillerons dans la première partie de ce rapport, ainsi que les algorithmes de génération de graphes demandés.
Dans une deuxième partie, nous décrirons les algorithmes implémentés et donnerons une estimation de leur complexité et les résultats obtenus.
Enfin, nous présenterons une solution via une réduction au problème de satisfiabilité et l'utilisation du solveur minisat.

Notations : dans ce rapport, le graphe considéré sera généralement noté $G$. Sa taille (le nombre de ses sommets) sera notée $n$. Les ensembles de ses sommets et de ses arêtes seront respectivement notés $V(G)$ et $E(G)$.

Le code est disponible à \href{http://github.com/ClairePennarun/CAA_Vertex_Cover }{l'adresse suivante}.

\section{Structure de graphes}

\subsection{Structure de données}

% On détaille l'implémentation des graphes et on explique nos choix. Surtout pour éviter de répéter la même chose au début de la description de chaque algorithme.

\subsection{Génération aléatoire}

% On explique rapidement comment fonctionne nos algorithmes de génération et quel est leur intérêt. Le plus important va être d'expliquer nos choix et ce qui aurait changé sur la fonction de répartition si on fait autrement.

\section{Algorithmes réalisés}

\subsection{Algorithme glouton}

 
\subsubsection{Description}

L'algorithme glouton consiste à ajouter à chaque étape le sommet qui couvrira le plus d'arêtes non couvertes. Bien que non optimal, il a l'avantage d'être rapide. 

Le nombre d'arêtes couvertes par un sommet est égal à son degré, mais quand un sommet est ajouté à la couverture, il est important de ne plus tenir compte des arêtes adjacentes dans la suite. Pour connaître rapidement le nombre d'arêtes que l'on couvrirait avec chaque sommet, nous avons choisi de créer un tableau répertoriant le degré de chaque sommet du graphe, plus facile à tenir à jour que le graphe lui-même. 

L'algorithme s'arrête quand il n'est plus possible de couvrir une nouvelle arête. Le tableau des degrés ne contiendra alors plus de valeur positive, ce qui se détecte facilement, puisqu'on doit de toute façon chercher le sommet de plus haut degré à chaque itération.

On obtient l'algorithme suivant :

\vspace{0.35cm}
\begin{algorithm}[H]

\Entree{Un graphe défini par un tableau $\mathtt{voisin}$ de listes d'adjacence}
\Sortie{Une couverture d'arêtes, sous forme de liste de sommets}
\BlankLine

$n=\taille(G)$

$\degmax=1$

$\cover = [\quad]$

création d'un tableau $\mathtt{degre}$ de taille $n$.

\Pour{$i$ do 0 à $n-1$}{

$\mathrm{\degree[i]\leftarrow \taille(\voisin[i])}$
}

\Tq{$\degmax\neq 0$}{

$v=\argmax(\degree)$

$\degmax=\degree[v]$

\Si{$\degmax\neq 0$}{

$\mathrm{ajouter}(\cover, v)$ % ou "ajouter $v$ a cover" ?

$\mathrm{actualiser}(\degree, v)$
}
}
\Retour{$\cover$}
\caption{Algorithme glouton}
 
\end{algorithm}

\vspace{0.35cm}
Si un sommet est ajouté à la couverture, on ne couvre plus d'arêtes en le couvrant une seconde fois. On peut donc passer sa valeur dans le tableau $\mathtt{degre}$ à 0. De plus, chaque sommet voisin couvre une arête de moins et on peut donc diminuer sa valeur de 1. Si on baisse de 1 la valeur d'un sommet qui a déjà été ajouté, on obtient des valeurs négatives, mais ce sont des sommets qui sont déjà dans la couverture, donc il n'y a pas de conséquence. Tester à chaque fois si le sommet appartient à la couverture ou non serait une perte de temps.

\vspace{0.35cm}
\begin{algorithm}[H]

\Entree{Le tableau $\mathtt{voisin}$, le tableau $\mathtt{degre}$ à mettre à jour et le sommet $v$ qu'on enlève du graphe}
\BlankLine
$\degree[v]=0$

\Pour{$i\in \voisin[v]$}{

décrémenter $\voisin[i]$ de 1
}
\caption{Actualiser}
 
\end{algorithm}

\subsubsection{Complexité}

\begin{itemize}
 \itemb La création du tableau $\mathtt{degre}$, incluant la boucle des lignes 5 et 6 se fait en $O(n)$
 \itemb On passera $c+1$ fois dans la boucle initiée à la ligne 7, où $c$ est la taille de la couverture renvoyée. À chaque fois :
\begin{itemize}
\itemt Déterminer le sommet de degré maximum (ligne 8) se fait en $O(n)$
\itemt La fonction actualiser tourne en $\deg(V)\leqslant n$.
\end{itemize}
\end{itemize}

Finalement, la complexité de l'algorithme glouton est $O(c\times n)$ (où $c$ est la taille de la couverture renvoyée).

Cependant, on peut remarquer que la phase de recherche du sommet de degré maximum pourrait se faire avec une complexité plus faible, car pour l'instant notre algorithme parcourt à chaque itération l'ensemble des sommets pour chercher celui de plus haut degré, et cela n'est pas efficace : à l'itération précédente, les seuls sommets qui ont changé de degré sont les voisins de celui que l'on a mis dans la couverture. Tenir à jour une liste des sommets triée en fonction de leur degré serait plus efficace : on déplacerait seulement les sommets ayant changé de degré à chaque itération.

\subsubsection{Résultats}

L'algorithme a été testé sur une série de 100 graphes, générés aléatoirement avec la fonction "generation", et une probabilité d'apparition des arêtes de 0.5. 
Les tests ont été effectués sur des machines du Cremi avec les caractéristiques techniques suivantes :
%%% A COMPLETER

\bigskip
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
	\hline 
	nb de sommets & 20 & 50 & 100 & 200 & 300 & 400 & 500 & 800 & 1000 \\
	\hline
	temps (s) & 0 & 0.02 & 0.08 & 0.51 & 1.4 & 3.68 & 9.95 &  & 185 \\
	\hline
\end{tabular}

\bigskip
Si on calcule le rapport $\frac{n^2}{temps(s)}$, on voit que ce rapport diminue, cela signifie que la complexité de l'algorithme est plus élevée que $O(n^2)$. Par contre, le rapport $\frac{n^3}{temps(s)}$ augmente au cours du temps, ce qui est significatif d'une complexité plus faible que $O(n^3)$. La complexité réelle de notre algorithme est donc moins bonne que la complexité estimée, et cela est peut-être dû à notre gestion du tableau des degrés, qui n'est pas optimale.

\subsection{Pour les arbres}

\subsubsection{Description}

L'algorithme optimal pour les arbres fonctionne de la façon suivante : on commence par chercher une feuille (notée $u$), il faudra forcément couvrir l'arête qui relie la feuille à son parent (noté $v$). Deux options s'offrent alors : ajouter $u$ à la couverture ou $v$. Comme l'ensemble des arêtes couverte par la feuille est inclus dans l'ensemble des arêtes couvertes par son parent, il y a forcément une couverture optimale qui contient $v$. 

Une fois que le parent est ajouté à la couverture, on peut supprimer toutes les arêtes qu'il couvre et les sommets orphelins, puis itérer, la terminaison étant assurée par le fait que le graphe est un arbre. Comme pour l'algorithme précédent, nous avons choisi de travailler sur un tableau contenant les degrés de chaque sommet, plus facile à tenir à jour que le graphe lui-même. Les feuilles étant caractérisées par un degré égal à 1, elles sont faciles à détecter à partir de ce tableau. On obtient l'algorithme suivant :

\vspace{0.35cm}
\begin{algorithm}[H]

\Entree{Un arbre défini par un tableau $\mathtt{voisin}$ de listes d'adjacence}
\Sortie{Une couverture d'arêtes, sous forme de liste de sommets}
\BlankLine

$n=\taille(G)$

création d'un tableau $\mathtt{degre}$ de taille $n$.

$\cover = [\quad]$

$\nonempty=\true$

\Pour{$i$ do 0 à $n-1$}{

$\mathrm{\degree[i]\leftarrow \taille(\voisin[i])}$
}

\Tq{$\nonempty$}{

$v=\leaf(\degree)$

\eSi{$v=-1$}{$\nonempty=\false$}
{$w=\parent(v,\degree,\voisin)$

$\mathrm{ajouter}(\cover, w)$

$\mathrm{actualiser}(\degree, w)$}

}

\Retour{$\cover$}
\caption{Algorithme optimal pour les arbres}
 
\end{algorithm}

Où la fonction $\leaf$ renvoie le premier sommet dont le degré est 1 (c'est-à-dire la première feuille), et -1 s'il n'y en a pas.

\subsubsection{Complexité}

\begin{itemize}
 \itemb La création du tableau $\mathtt{degre}$, incluant la boucle des lignes 5 et 6 se fait en $O(n)$
 \itemb On passera $c+1$ fois dans la boucle initiée à la ligne 7, où $c$ est la taille de la couverture renvoyée. À chaque fois :
\begin{itemize}
\itemt La fonction $\leaf$ tourne en $O(n)$.
\itemt La fonction actualiser tourne en $\deg(V)\leqslant n$.
\end{itemize}
\end{itemize}

Finalement, la complexité finale de l'algorithme glouton est $O(c\times n)$ (où $c$ est la taille de la couverture renvoyée).

\subsubsection{Résultats}

\bigskip
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline 
	nb de sommets & 200 & 300 & 500 & 1000 & 1500 & 2000 & 5000 & 10000 & 15000 & 20000 & 50000 \\
	\hline
	temps (s) & 0.01 & 0.03 & 0.06 & 0.22 & 0.41 & 0.77 & 4.38 & 16.92 & 37 & 65 & 442 \\
	\hline
\end{tabular}

En calculant le rapport $\frac{n^2}{temps(s)}$, on voit qu'il augmente très légèrement : cela signifie que notre algorithme a une complexité légèrement meilleure que $O(n^2)$, ce qui est bien.

\subsection{Pour les graphes bipartis}

\subsubsection{Description}

% On explique le principe de l'algorithme, nos choix pour l'implémentation (ici, le tableau de degré par exemple), et on donne le pseudo-code.

\subsubsection{Complexité}

% Étude théorique de la complexité de l'algorithme. Éventuellement, quelle aurait été la complexité si on avait fait d'autres choix d'implémentation.

\subsubsection{Résultats}

% On chronomètre sur une batteries de graphes générés aléatoirement, on commente et on interprète. Je pense que cette partie est importante, c'est ce qui justifie l'implémentation de générateurs.

\subsection{Algorithme 2-approché avec arbre couvrant}

\subsubsection{Description}

L'algorithme se base sur un parcours en profondeur du graphe $G$. Le parcours en profondeur (DFS) crée un arbre couvrant du graphe. Notons que si deux sommets sont liés par une arête, le premier des deux à être visité ne sera pas une feuille de l'arbre puisqu'il a au moins un fils qui n'a pas encore été visité. Par contraposée, il ne peut pas y avoir d'arêtes entre deux feuilles de l'arbre induit par le DFS et l'ensemble des sommets de cet arbre qui ne sont pas des feuilles est donc une couverture du graphe. 

Partitionnons maintenant notre couverture en l'ensemble des nœuds de l'arbre de profondeur paire et ceux de profondeur impaire et intéressons nous à l'ensemble $E$ de plus grand cardinal. La taille de notre couverture est donc majorée par $2|E|$. En reliant chaque sommet de $E$ à son fils, on crée un ensemble d'arêtes indépendantes : en effet, notre couverture ne comportant pas de feuilles, chacun de ses sommets a un fils, et le profondeur du fils étant de parité différente de celle du père, le fils n'appartient pas à $E$. Ainsi, $|E|$ est un minorant de la taille d'une couverture de $G$. Notre algorithme est donc 2-approché.


Nous avons implémenté cet algorithme de deux manières différentes : la première version (algorithme \og spanningTreeAlgRec\fg) en nous basant sur un algorithme récursif simple de parcours en profondeur, la deuxième version (algorithme \og spanningTreeAlg\fg) en dérécursifiant le parcours en utilisant une liste doublement chaînée comme pile.

Chaque sommet de $G$ est \og coloré\fg quand il est visité par le parcours. Un tableau $\Color$ de taille $n$ est créé au début de l'algorithme pour nous permettre de stocker ces "couleurs" : 

\begin{itemize}
\item dans le premier algorithme : $\Color[i] = 0$ si le sommet $i$ n'a pas encore été visité, $\Color[i] = 1$ sinon.
\item dans le second algorithme : $\Color[i] = 0$ si le sommet $i$ n'a pas encore été visité, $\Color[i] = 1$ si le sommet est a été découvert (il est voisin d'un sommet visité), et $\Color[i] = 2$ si le sommet a été visité.
\end{itemize}



Pour savoir si un sommet $v$ est une feuille ou non, nous utilisons un booléen $\mathrm{isInCover}$ qui vaut $\false$ au début de la visite de $v$. Quand on rencontre pour la première fois un de ses voisins non déjà visité, le sommet $v$ est ajouté dans la couverture du graphe et la valeur de $\mathrm{isInCover}$ est mise à $\true$.

\vspace{0.35cm}
\begin{algorithm}[H]

\Entree{le graphe $g$}
\Sortie{Une couverture d'arêtes, sous forme de liste de sommets $cover$}
\BlankLine
$n \leftarrow \taille(G)$

$t \leftarrow$ tableau de taille $n$

$\cover \leftarrow$ liste

\Pour{$i\in V(G)$}
{$t[i] = 0$}

parcours\_profondeur($G, 0, \cover, t$)

\Retour{cover}
\caption{Algorithme avec arbre couvrant (récursif) - spanningTreeAlgRec}
 
\end{algorithm}

\vspace{0.35cm}
\begin{algorithm}[H]

\Entree{le graphe $G$, le sommet $v$ sur lequel on fait le parcours, la couverture $cover$ de sommets actuelle, le tableau de couleurs $t$}
\BlankLine

\Si{$t[v] = 1$}{
Fin du programme
}

estDansCover = False

$t[v] = 1$

\Pour{$i\in \voisin[v]$}{
\Si{$t[i] = 0$ et estDansCover = False}{
	ajout de $v$ à $\cover$
	
	estDansCover = True
	}	
parcours\_profondeur($G$, $i$, $\cover$, $t$)
}
\caption{parcours\_profondeur - dfs}
 
\end{algorithm}

\vspace{0.35cm}
\begin{algorithm}[H]

\Entree{le graphe $G$}
\BlankLine

$\cover \leftarrow$ liste % a voir si externe

pile$ \leftarrow$ liste % a voir si externe

\Pour{$i \in V(G)$}{
	$\Color[i] = 0$;
	$\parent[i] = -1$;
}

$u$ $\leftarrow$ racine du graphe

$\Color[u] = 1$;

ajout de $u$ à pile

\Tq{pile $\neq$ []}{
	estDansCover = False
	
	$u \leftarrow$ tête de $pile$
	
	\Si{$\Color[u] \neq 2$}{
		$\Color[u] = 2$
	
		\Pour{$v \in voisin[u]$}{
			\Si{$\Color[v] \neq 2$}{
			$\Color[v] = 1$
			
			$\parent[v] = u$
			
			empiler $v$ dans pile
			
				\Si{estDansCover = False}{
				ajouter $u$ dans $\cover$
				
				estDansCover = True
				}
			}
		}
	}
}
\Retour{$\cover$}

\caption{Algorithme avec arbre couvrant (itératif) - spanningTreeAlg}
 
\end{algorithm}

\subsubsection{Complexité}

L'algorithme présenté demande un préprocessing faisable en temps linéaire (initialiser $t$ ou $\Color$), puis une opération sur les voisins de chaque sommet, qui requiert donc un temps en $O(|E|)$. La complexité temporelle de l'algorithme est donc $O(|E|)$.

\subsubsection{Résultats}

Pour l'algorithme récursif :

\bigskip
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
	\hline 
	nb de sommets & 100 & 200 & 300 & 500 & 800 & 1000 & 1500 & 2000 & 2500 \\
	\hline
	temps (s) &  &  &  &  &  &  &  &  & \\
	\hline
\end{tabular}

%% A COMPLETER
\bigskip 
Pour l'algorithme itératif :

\bigskip
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
	\hline 
	nb de sommets & 100 & 200 & 300 & 500 & 800 & 1000 & 1500 & 2000 & 2500 \\
	\hline
	temps (s) &  &  &  &  &  &  &  &  & \\
	\hline
\end{tabular}

On voit que l'algorithme itératif va plus vite que sa version récursive.
% de combien ?
% complexité des deux versions : la même normalement !!

\subsection{Algorithme 2-approché par élimination d'arêtes}

\subsubsection{Description}

L'idée de cet algorithme est de choisir une arête du graphe, d'ajouter ses deux extrémités à la couverture et des les supprimer du graphe (ainsi que toutes les arêtes adjacentes), et d'itérer jusqu'à ce que le graphe n'ait plus d'arêtes. Ainsi, les arêtes tirées à chaque itération forment un ensemble d'arêtes indépendantes, et la taille de la couverture obtenue sera égale à deux fois la taille de cet ensemble. On remarque alors que la taille d'un ensemble d'arêtes indépendantes est un minorant de la taille d'une couverture du graphe puisqu'il faut un sommet différent pour couvrir chacune des arêtes de l'ensemble. L'algorithme décrit est donc 2-approché.

\vspace{0.35cm}
\begin{algorithm}[H]

\Entree{Un graphe $G$ défini par un tableau $\mathtt{voisin}$ de listes d'adjacence}
\Sortie{Une couverture d'arêtes, sous forme de liste de sommets}
\BlankLine

$n=\taille(G)$

$v_1=\degrepositif(G,0)$

\Si{$v_1=0$}{\Retour{$\cover$}}

$\deg_1=\deg(v_1)$

\Tq{$\deg_1>0$}{

$\voisins=\voisin(v_1)$

$v_2$ est le premier élément de $\voisins$

$\mathrm{ajouter}(\cover,v_1)$

$\mathrm{ajouter}(\cover,v_2)$

$\mathrm{suppressionAretes}(G,v_1)$

$\mathrm{suppressionAretes}(G,v_2)$

$v_1=\degrepositif(G,v_1)$

\Si{$v_1=0$}{\Retour{$\cover$}}

$\deg_1=\deg(v_1)$

}


\Retour{$\cover$}
\caption{Algorithme par élimination d'arêtes}
 
\end{algorithm}

La fonction \texttt{degrePositif} prend en argument un graphe $G$ et un indice $i$ et renvoie le premier sommet de $G$ de degré positif et d'indice supérieur à $i$, ou -1 s'il n'y en a pas. Si la dernière fois que la fonction a été appelée, le premier sommet de degré positif avait comme indice $i$, il est en effet inutile de chercher un sommet de degré positif avant l'indice $i$ puisque l'algorithme ne peut à aucun moment augmenter le degré d'un sommet.

\vspace{0.35cm}
\begin{algorithm}[H]

\Entree{Un graphe $G$ défini par un tableau $\mathtt{voisin}$ de listes d'adjacence, un indice $i$}
\Sortie{Le premier sommet de $G$ de degré positif et d'indice supérieur à $i$}
\BlankLine

\Pour{$j$ de $i$ à $\taille(G)-1$}{

\Si{$\voisin(j)\neq [\quad]$}{\Retour{$j$}
}
}
\Retour {-1}


\caption{degrePositif}
 
\end{algorithm}

La fonction \texttt{suppressionAretes} prend en entrée un graphe $G$ et un sommet $v$ et supprime de $G$ toutes les arêtes adjacentes à $v$.

\vspace{0.35cm}
\begin{algorithm}[H]

\Entree{Un graphe $G$ défini par un tableau $\mathtt{voisin}$ de listes d'adjacence, un sommet $v$}
\BlankLine

\Pour{$u\in\voisin(v)$}{

$\mathrm{supprimer}(v,\voisin(u))$
}

$\voisin(v)\leftarrow [\quad]$

\caption{suppressionAretes}
 
\end{algorithm}

\subsubsection{Complexité}

Le nombre d'appels de la fonction \texttt{degrePositif} importe en fait assez peu : le fait que la fonction garde en mémoire l'indice du dernier sommet trouvé assure que la somme des temps d'exécution sera en $O(n)$. La complexité de l'algorithme viendra donc des appels de la fonction \texttt{suppressionAretes}, aux lignes 11 et 12. On sait que la fonction \texttt{suppressionAretes} supprimera au maximum $|E(G)|$ arêtes et que chaque suppression d'arête demandera de chercher un élément dans une liste de voisins d'un sommet, de taille majorée par $\Delta(G)$.

Ainsi, l'algorithme tourne en $O(|E|\times \Delta(G))$ où $\Delta(G)$ est le degré maximum du graphe.

\subsubsection{Résultats}


\subsection{Algorithme paramétrique pour faible couverture}

\subsubsection{Description}

L'algorithme paramétrique permet de tester si le graphe comporte une couverture par sommets d'une taille $k$ donnée, et de la retourner le cas échéant.

\bigskip
Pour cela, nous commençons par effectuer une kernelisation du problème. Soit $U = \{ v \in V(G) \mid deg(v) > k\}$. On sait que $G$ admet une $k$-couverture si et seulement si $G \smallsetminus U$ admet une $(k - |U|)$-couverture.

On recherche donc le nombre $l = |U|$ de sommets de degré strictement supérieur à $k$. 
Si $l > k$, alors on ne pourra pas trouver de couverture de taille $k$ et on peut arrêter l'algorithme.
Si le graphe comprend plus de $k\times(k-l)$ arêtes, on peut également arrêter l'algorithme.

Si ces deux tests n'entraînent pas l'arrêt de l'algorithme, on \og réduit\fg le graphe $G$ à $G \smallsetminus U \smallsetminus \{v \in V \mid deg(v) = 0\}$, en cherchant une couverture plus petite, de taille $k-l$.

\vspace{0.35cm}
\begin{algorithm}[H]

\Entree{Un graphe $G$, la taille $k$ de la couverture recherchée}
\BlankLine

$l = 0$ \tcp*{nombre de sommets de degré trop grand}

$m = 0$ \tcp*{nombre de sommets isolés}

$n = \taille(G)$

gdDegres \tcp*{tableau de sommets de degré trop grand}

degreNul \tcp*{tableau de sommets de degré nul}

\Pour{$v \in V(G)$}{
	\Si{$\deg(v) > k$}{
		gdDegres[$l$] = $v$
		
		$l = l+1$
	}
	\Si{$\deg(v) = 0$}{
		degreNul[$m$] = $v$
		
		$m = m+1$
	}
}

$k' = k - l$

\Si{$k'\leqslant 0$}{
	\Retour{NULL}
}
\Si{$l>0$}{
	\Pour{$i$ de 0 à $l-1$}{
		$u$ = grdDegres[$i$]
		
		suppressionAretes($G$,$u$)
		
		suppressionSommet($G$,$u$)
	}
}
\Si{$m>0$}{
	\Pour{$i$ de 0 à $m-1$}{
		$u$ = degreNul[$i$]
		
		suppressionSommet($G$,$u$)
	}
}

\Si{nombreAretes($G$) $> k\times k'$}{
	\Retour {NULL}
}
$\cover$ = petiteCouvertureAlg($G$,$k'$,$n-l$)

\Pour{$i$ de 0 à $l-1$}{
	ajouter grdDegres[$i$] à $\cover$
}

\Retour{$\cover$}

\caption{recherchePetiteCouverture - littleCover}
\end{algorithm}

L'algorithme principal est ensuite appliqué. Il consiste en une série de tests qui permettent soit d'écarter rapidement la possibilité de l'existence d'une couverture de taille $k$, soit de renvoyer directement une telle couverture. 

Les tests sont : 
\begin{itemize}
\item si $k$ est supérieur à la taille du graphe, alors tous les sommets sont dans la couverture.
\item si $k$ est négatif, alors le graphe n'a pas de couverture de taille $k$.
\item si le graphe comporte plus de $k\times(n-1)$ arêtes, alors il n'a pas de couverture de taille $k$.
\end{itemize}

\bigskip

Si les tests ne permettent pas de conclure, une arête $(u,v)$ du graphe est considérée, et l'algorithme est lancé récursivement sur $G - \{u\}$ et $G - \{v\}$, avec la recherche d'une couverture de taille $k-1$. Si l'un des deux appels récursifs (disons celui sur $G - \{u\}$) renvoie une couverture $\cover$ de taille $k-1$, alors le graphe $G$ contient une couverture de taille $k$, qui s'obtient en ajoutant le sommet $u$ à $\cover$.

Remarque : dans cet algorithme, quand un sommet est supprimé, le graphe garde la même taille $n$ mais ce sommet est noté \og NULL\fg. Donc il faut conserver en mémoire la taille du graphe de départ tout en travaillant sur un sous-graphe induit de taille $n'$ plus réduite.

\vspace{0.35cm}
\begin{algorithm}[H]

\Entree{Un sous-graphe induit $G'$ du graphe $G$, la taille $k$ de la couverture recherchée, la taille $n'$ de $G'$}
\Sortie{Une couverture d'arêtes de taille $k$, sous forme de liste de sommets $cover$}
\BlankLine

\Si{$n' < k$}{
	\Pour{$v \in V(G)$}{
		\Si{$\voisins[v] \neq$ NULL}{
			ajouter $v$ à $\cover$
		}
	}
	\Retour{$\cover$}
}

\Si{$k < 0$}{
	\Retour{NULL}
}

\Si{nombreAretes($G'$) $> k\times(n'-1)$}{
	\Retour{NULL}
}

creation d'un tableau des degres de taille $n$

$u$ = degrePositif($G$,0)

$v$ = voisin de $u$

$g_1$ = copie($G$)

suppressionAretes($g_1$,$u$)

suppressionSommet($g_1$,$u$)

\Si{nombreAretes($g_1$) = 0}{
	ajouter $u$ à $\cover$
	\Retour{$\cover$}
}

$g_2$ = copie($G$)

suppressionAretes($g_2$,$v$)

suppressionSommet($g_2$,$v$)

\Si{nombreAretes($g_2$) = 0}{
	ajouter $v$ à $\cover$
	\Retour{$\cover$}
}

$\mathrm{coverU}$ = petiteCouvertureAlg($g_1$,$k-1$,$n'-1$)

\Si{coverU $\neq$ NULL et taille(coverU) = $k-1$}{
	$\cover$ = $\mathrm{coverU}$
	
	ajouter $u$ à $\cover$
}

\Sinon{
	$\mathrm{coverV}$ = petiteCouvertureAlg($g_2$,$k-1$,$n'-1$)

	\Si{$\mathrm{coverV} \neq$ NULL et taille(coverV) = $k-1$}{
		$\cover$ = $\mathrm{coverV}$
	
		ajouter $v$ à $\cover$
	}
}

\Retour{$\cover$}

\caption{petiteCouvertureAlg - littleCoverAlg}
\end{algorithm}

\subsubsection{Complexité}

Commençons par estimer la complexité de l'algorithme \texttt{littleCoverAlg}. À chaque appel récursif, si la condition d'arrêt n'est pas remplie, l'algorithme va :
\begin{itemize}
 \itemb créer les graphes $g_1$ et $g_2$. La création de ces graphes se fait en parcourant l'ensemble des arêtes, dont la taille est majorée par $k(n-1)$ (condition d'arrêt).
 \itemb s'appeler deux fois lui-même. On obtient ainsi un arbre d'appel d'arité 2.
 \itemb ajouter un sommet à la couverture, la profondeur de l'arbre d'appel est donc majoré par la taille $k$ de la couverture cherchée.
\end{itemize}

Ainsi, l'algorithme \texttt{littleCoverAlg} tournera en $O(2^k k\times n)$. 

\vspace{0.35cm}
Étudions maintenant l'algorithme \texttt{littleCover}. La boucle \texttt{pour} des lignes 6 à 12 demande de déterminer pour chacun des $n$ sommets si son degré est plus grand que $k$ (se fait en $O(k)$). Cette étape de preprocessing ne sera fait qu'une seule fois et sa complexité sera asymptotiquement négligeable. Après cette étape, on appellera \texttt{littleCoverAlg} sur le graphe induit par les sommets restants de degré non nul, si et seulement si ce graphe a moins de $k^2$ arêtes donc moins de $2k^2$ sommets. Comme l'algorithme tourne en $O(2^k k\times n)$, avec $n\leqslant k^2$, l'algorithme final tourne en $O(2^k k^3)$.

\subsubsection{Résultats}

\section{Résolution avec un sat-solver}

% Proposition de plan qui va sûrement évoluer quand on se sera penchés sur cette partie.

\subsection{Réduction}

\subsection{Algorithme et complexité}

% Je sais pas si on aura grand chose à dire sur notre implémentation des algorithmes de réduction, mais leur complexité et surtout la complexité du problème sat induit sont intéressantes.

\subsection{Résultats}

\end{document}
