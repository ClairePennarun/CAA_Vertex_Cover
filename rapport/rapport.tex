\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[french,ruled,vlined,linesnumbered]{algorithm2e}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\newcommand*{\itemb}{\item[$\bullet$]}
\newcommand*{\itemt}{\item[$\blacktriangleright$]}
\DeclareMathOperator{\degree}{degre}
\DeclareMathOperator{\taille}{taille}
\DeclareMathOperator{\voisin}{voisin}
\DeclareMathOperator{\degmax}{degmax}
\DeclareMathOperator{\argmax}{argmax}
\DeclareMathOperator{\argmin}{argmin}
\DeclareMathOperator{\cover}{cover}
\DeclareMathOperator{\nonempty}{nonempty}
\DeclareMathOperator{\true}{true}
\DeclareMathOperator{\false}{false}
\DeclareMathOperator{\leaf}{leaf}
\DeclareMathOperator{\parent}{parent}
\title{Projet CAA : couverture par sommets}
\author{Thomas \bsc{Bellitto}\and Paul-Émile \bsc{Boutoille} \and Claire \bsc{Pennarun}}
\date{}

\begin{document}

\maketitle

\section*{Introduction}

Le projet consiste en l'implémentation d'algorithmes résolvant de manière approchée (en général) ou optimale (pour certaines classes de graphes) le problème Vertex-Cover.
Les algorithmes présentés ici renvoient une liste des sommets formant une couverture du graphe. Cette couverture n'est cependant pas forcément minimale.

Nous avons implémenté l'ensemble de ces algorithmes en langage C, car le groupe était plus à l'aise dans ce langage qu'en C++.

Nous avons développé une structure de graphes que nous détaillerons dans la première partie de ce rapport, ainsi que les algorithmes de génération de graphes demandés.
Dans une deuxième partie, nous décrirons les algorithmes implémentés, une estimation de leur complexité et les résultats obtenus.
Enfin, nous présenterons l'utilisation de minisat que nous avons développé.

Notations : dans ce rapport, le graphe considéré sera généralement noté $G$. Sa taille (le nombre de ses sommets) sera notée $n$. Les ensembles de ses sommets et de ses arêtes seront respectivement notés $V(G)$ et $E(G)$.

\section{Structure de graphes}

\subsection{Structure de données}

% On détaille l'implémentation des graphes et on explique nos choix. Surtout pour éviter de répéter la même chose au début de la description de chaque algorithme.

\subsection{Génération aléatoire}

% On explique rapidement comment fonctionne nos algorithmes de génération et quel est leur intérêt. Le plus important va être d'expliquer nos choix et ce qui aurait changé sur la fonction de répartition si on fait autrement.

\section{Algorithmes réalisés}

\subsection{Algorithme glouton}

 
\subsubsection{Description}

L'algorithme glouton consiste à ajouter à chaque étape le sommet qui couvrira le plus d'arêtes non couvertes. Bien que non optimal, il a l'avantage d'être rapide. 

Le nombre d'arêtes couvertes par un sommet est égal à son degré, mais quand un sommet est ajouté à la couverture, il est important de ne plus tenir compte des arêtes adjacentes dans la suite. Pour connaître rapidement, le nombre d'arêtes que l'on couvrirait avec chaque sommet, nous avons choisi de créer un tableau répertoriant le degré de chaque sommet du graphe, plus facile à tenir à jour que le graphe lui-même. 

L'algorithme s'arrête quand il n'est plus possible de couvrir une nouvelle arête. Le tableau des degrés ne contiendra alors plus de valeur positive, ce qui se détecte facilement, puisqu'on doit de toute façon chercher le sommet de plus haut degré à chaque itération.

On obtient l'algorithme suivant :

\vspace{0.35cm}
\begin{algorithm}[H]

\Entree{Un graphe défini par un tableau $\mathtt{voisin}$ de listes d'adjacence}
\Sortie{Une couverture d'arêtes, sous forme de liste de sommets}
\BlankLine

$n=\taille(G)$

$\degmax=1$

création d'un tableau $\mathtt{degre}$ de taille $n$.

\Pour{$i$ do 0 à $n-1$}{

$\mathrm{\degree[i]\leftarrow \taille(\voisin[i])}$
}

\Tq{$\degmax\neq 0$}{

$v=\argmax(\degree)$

$\degmax=\degree[v]$

\Si{$\degmax\neq 0$}{

$\mathrm{ajouter}(\cover, v)$ % ou "ajouter $v$ a cover" ?

$\mathrm{actualiser}(\degree, v)$
}
}
\Retour{$\cover$}
\caption{Algorithme glouton}
 
\end{algorithm}

\vspace{0.35cm}
Si un sommet est ajouté à la couverture, on ne couvre plus d'arêtes en le couvrant une seconde fois. On peut donc passer sa valeur dans le tableau $\mathtt{degre}$ à 0. De plus, chaque sommet voisin couvre une arête de moins et on peut donc diminuer sa valeur de 1. Si on baisse de 1 la valeur d'un sommet qui a déjà été ajouté, on obtient des valeurs négatives, mais ce sont des sommets qui sont déjà dans la couverture, donc il n'y a pas de conséquence. Tester à chaque fois si le sommet appartient à la couverture ou non serait une perte de temps.

\vspace{0.35cm}
\begin{algorithm}[H]

\Entree{Le tableau $\mathtt{voisin}$, le tableau $\mathtt{degre}$ à mettre à jour et le sommet $v$ qu'on enlève du graphe}
\BlankLine
$\degree[v]=0$

\Pour{$i\in \voisin[v]$}{

décrémenter $\voisin[i]$ de 1
}
\caption{Actualiser}
 
\end{algorithm}

\subsubsection{Complexité}

\begin{itemize}
 \itemb La création du tableau $\mathtt{degre}$, incluant la boucle des lignes 4 et 5 se fait en $O(n)$
 \itemb On passera $c+1$ fois dans la boucle initiée à la ligne 6, où $c$ est la taille de la couverture renvoyée. À chaque fois :
\begin{itemize}
\itemt Déterminer le sommet de degré maximum (ligne 7) se fait en $O(n)$
\itemt La fonction actualiser tourne en $\deg(V)\leqslant n$.
\end{itemize}
\end{itemize}

Finalement, la complexité de l'algorithme glouton est $O(cn)$ (où $c$ est la taille de la couverture renvoyée).

Cependant, on peut remarquer que la phase de recherche du sommet de degré maximum pourrait se faire avec une complexité plus faible, car pour l'instant notre algorithme parcourt à chaque itération l'ensemble des sommets pour chercher celui de plus haut degré, et cela n'est pas efficace : à l'itération précédente, les seuls sommets qui ont changé de degré sont les voisins de celui que l'on a mis dans la couverture. Tenir à jour une liste des sommets triée en fonction de leur degré serait plus efficace : on déplacerait seulement les sommets ayant changé de degré à chaque itération.

\subsubsection{Résultats}

\subsection{Pour les arbres}

\subsubsection{Description}

L'algorithme optimal pour les arbres fonctionne de la façon suivante : on commence par chercher une feuille, il faudra forcément couvrir l'arête qui relie la feuille à son parent. Deux options s'offrent alors : ajouter la feuille à la couverture ou son parent. Comme l'ensemble des arêtes couverte par la feuille est inclus dans l'ensemble des arêtes couvertes par son parent, il y a forcément une couverture optimale qui contient le parent. 

Une fois que le parent est ajouté à la couverture, on peut supprimer toutes les arêtes qu'il couvre et les sommets orphelins, puis itérer, la terminaison étant assuré par le fait que le graphe est un arbre. Comme pour l'algorithme précédent, nous avons choisi de travailler sur un tableau contenant les degré de chaque sommet, plus facile à tenir à jour que le graphe lui-même. Les feuilles étant caractérisée par un degré égal à 1, elles sont faciles à détecter à partir de ce tableau. On obtient l'algorithme suivant :

\vspace{0.35cm}
\begin{algorithm}[H]

\Entree{Un arbre défini par un tableau $\mathtt{voisin}$ de listes d'adjacence}
\Sortie{Une couverture d'arêtes, sous forme de liste de sommets}
\BlankLine

$n=\taille(G)$

création d'un tableau $\mathtt{degre}$ de taille $n$.

$\nonempty=\true$

\Pour{$i$ do 0 à $n-1$}{

$\mathrm{\degree[i]\leftarrow \taille(\voisin[i])}$
}

\Tq{$\nonempty$}{

$v=\leaf(\degree)$

\eSi{$v=-1$}{$\nonempty=\false$}
{$w=\parent(v,\degree,\voisin)$

$\mathrm{ajouter}(\cover, w)$

$\mathrm{actualiser}(\degree, w)$}

}

\Retour{$\cover$}
\caption{Algorithme optimal pour les arbres}
 
\end{algorithm}

Où la fonction $\leaf$ renvoie le premier sommet dont le degré est 1, et -1 s'il n'y en a pas.

\subsubsection{Complexité}

\begin{itemize}
 \itemb La création du tableau $\mathtt{degre}$, incluant la boucle des lignes 4 et 5 se fait en $O(n)$
 \itemb On passera $c+1$ fois dans la boucle initiée à la ligne 6, où $c$ est la taille de la couverture renvoyée. À chaque fois :
\begin{itemize}
\itemt La fonction $\leaf$ tourne en $O(n)$.
\itemt La fonction actualiser tourne en $\deg(V)\leqslant n$.
\end{itemize}
\end{itemize}

Finalement, la complexité finale de l'algorithme glouton est $O(cn)$ (où $c$ est la taille de la couverture renvoyée).

\subsubsection{Résultats}

\subsection{Pour les graphes bipartis}

\subsubsection{Description}

% On explique le principe de l'algorithme, nos choix pour l'implémentation (ici, le tableau de degré par exemple), et on donne le pseudo-code.

\subsubsection{Complexité}

% Étude théorique de la complexité de l'algorithme. Éventuellement, quelle aurait été la complexité si on avait fait d'autres choix d'implémentation.

\subsubsection{Résultats}

% On chronomètre sur une batteries de graphes générés aléatoirement, on commente et on interprète. Je pense que cette partie est importante, c'est ce qui justifie l'implémentation de générateurs.

\subsection{Algorithme 2-approché avec arbre couvrant}

\subsubsection{Description}

L'algorithme se base sur un parcours en profondeur du graphe $G$. Le parcours en profondeur (DFS) crée un arbre couvrant du graphe. L'ensemble des sommets de cet arbre qui ne sont pas des feuilles est retourné comme couverture du graphe.

Nous avons implémenté cet algorithme en nous basant sur un algorithme récursif simple de parcours en profondeur. Chaque sommet de $G$ est "marqué" quand il est visité par le parcours. Un tableau $t$ de taille $n$ est créé au début de l'algorithme pour nous permettre de stocker ces "marques" : $t[i] = 0$ si le sommet $i$ n'a pas encore été visité, $t[i] = 1$ sinon.

Pour savoir si un sommet $v$ est une feuille ou non, nous utilisons un booléen $aSuccesseur$ ($hasSuccessor$) qui vaut $False$ au début de la visite de $v$ et dont la valeur vaut $True$ quand on rencontre un de ses voisins pour la première fois. Le sommet $v$ est alors ajouté dans la couverture du graphe.

Cet algorithme est 2-approché, c'est-à-dire qu'il retourne un ensemble de sommets de cardinal au pire deux fois plus grand que celui de la couverture minimale du graphe.

\begin{algorithm}[H]

\Entree{le graphe $g$}
\Sortie{Une couverture d'arêtes, sous forme de liste de sommets $cover$}
\BlankLine
$n \leftarrow \taille(G)$

$t \leftarrow$ tableau de taille $n$

pour tous les sommets $i$ de $V(G)$ : $t[i] \leftarrow 0$

parcours\_profondeur(G, 0, cover, t)

\Retour{cover}
\caption{Algorithme avec arbre couvrant}
 
\end{algorithm}

\begin{algorithm}[H]

\Entree{le graphe $G$, le sommet $v$ sur lequel on fait le parcours, la couverture $cover$ de sommets actuelle, le tableau de marques $t$}
\BlankLine

\Si{t[v] = 1}{
\Retour {}
}

aSuccesseur $\leftarrow$ False

t[v] $\leftarrow$ 1

\Pour{$i\in \voisin[v]$}{
\Si{t[i] = 0 et aSuccesseur = False}{
	aSuccesseur $\leftarrow$ True
	
	ajout de $v$ à $cover$
	}	
parcours\_profondeur(G, i, cover, t)
}
\caption{parcours\_profondeur}
 
\end{algorithm}

\subsubsection{Complexité}

\subsubsection{Résultats}


\subsection{Algorithme 2-approché avec élimination d'arêtes}

\subsubsection{Description}

\subsubsection{Complexité}

\subsubsection{Résultats}


\subsection{Algorithme paramétrique pour faible couverture}

\subsubsection{Description}

\subsubsection{Complexité}

\subsubsection{Résultats}


\section{Résolution avec un sat-solver}

% Proposition de plan qui va sûrement évoluer quand on se sera penchés sur cette partie.

\subsection{Réduction}

\subsection{Algorithme et complexité}

% Je sais pas si on aura grand chose à dire sur notre implémentation des algorithmes de réduction, mais leur complexité et surtout la complexité du problème sat induit sont intéressantes.

\subsection{Résultats}

\end{document}
